var documenterSearchIndex = {"docs":
[{"location":"private/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"private/#Contents","page":"Internals","title":"Contents","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Pages = [\"private.md\"]\nDepth = 3","category":"page"},{"location":"private/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Pages = [\"private.md\"]","category":"page"},{"location":"private/#Private-Interface","page":"Internals","title":"Private Interface","text":"","category":"section"},{"location":"private/#Cluster-Models","page":"Internals","title":"Cluster Models","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Modules = [BayesJ]\nPublic  = false\nPrivate = true\nPages   = [\"gas_models.jl\"]","category":"page"},{"location":"private/#BayesJ.Model_NFW_GNFW-Union{Tuple{T}, Tuple{N}, Tuple{T, T, T, T, T, T, T, Vector{N}, Union{Unitful.Quantity{T, ùêÄ, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêÄ, U}} where {L, S}} where U, Any, Union{Unitful.Quantity{T, ùêì, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêì, U}} where {L, S}} where U, Matrix, Any}} where {N<:Integer, T<:AbstractFloat}","page":"Internals","title":"BayesJ.Model_NFW_GNFW","text":"Model_NFW_GNFW_GNFW(MT_200, fg_200, Œ±, Œ≤, Œ≥, c_500_GNFW, z, shape, pixel_edge_angle, emission_model, exposure_time, response_function)\n\nCalculate predicted counts using a physical model based NFW-GNFW profiles as described in Olamaie 2012.\n\nThe first six parameters are model priors.  z is redshift and shape describes the size of the source number as a number of spatial bins in each dimension. The pixel edge angle describes the angular size observed by a single pixel in units such as arcseconds. This area is assumed to be square with the edge angle giving the side length. The emission model should be a function compatible with the requirements of the surface_brightness function, which it will be passed to. The response function includes both the RMF and ARF, as described in apply_response_function.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.œÅ_crit-Tuple{Any}","page":"Internals","title":"BayesJ.œÅ_crit","text":"p_crit(z)\n\nCalculate the critical density at some redshift z.\n\n\n\n\n\n","category":"method"},{"location":"private/#Constants","page":"Internals","title":"Constants","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Modules = [BayesJ]\nPublic  = false\nPrivate = true\nPages   = [\"params.jl\"]","category":"page"},{"location":"private/#BayesJ.cosmo","page":"Internals","title":"BayesJ.cosmo","text":"Cosmology assumed by BayesX\n\nDefaults to:\n\nh=0.69,\nNeff=3.04,\nOmegaK=0,\nOmegaM=0.29,\nOmegaR=nothing,\nTcmb=2.7255,\nw0=-1,\nwa=0\n\n\n\n\n\n","category":"constant"},{"location":"private/#BayesJ.Œº","page":"Internals","title":"BayesJ.Œº","text":"Mean mass per gas particle = 0.6m‚Çö\n\n\n\n\n\n","category":"constant"},{"location":"private/#BayesJ.Œº_e","page":"Internals","title":"BayesJ.Œº_e","text":"Mean gas mass per electron = 1.14m‚Çö\n\n\n\n\n\n","category":"constant"},{"location":"private/#Emissions-Modelling","page":"Internals","title":"Emissions Modelling","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Modules = [BayesJ]\nPublic  = false\nPrivate = true\nPages   = [\"emission.jl\", \"mekal.jl\"]","category":"page"},{"location":"private/#BayesJ.apply_response_function-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, T}} where T<:AbstractFloat","page":"Internals","title":"BayesJ.apply_response_function","text":"apply_response_function(counts_per_bin::Vector, response::Matrix, exposure_time::Unitful.Time)::Vector{Float64}\n\nApplies the response function RSP(PI E) = RMF(PI E)  ARF(E) to all energy bins and returns adjusted counts per bin.\n\nbeginaligned\nC(PI) = T int RMF(PI E)  ARF(E)  S(E)  dE \n T sum_j R_ij Aj Sj\nendaligned\n\nwith C(PI) is the observed counts in a detector channel PI, T is the observation time, ARF(E) is the effective area of the instrument and RMF(E, PI) is the unitless response matrix. (Handbook of X-ray Astronomy Chapter 2011, Chapter 5 pg 87, by K. Arnaud, R. Smith and A. Siemiginowska)\n\nThis function takes the combined RMF and ARF as the response function. This is to recalculating it on every call. Some people format the RMF as RMF(PI, E). This convention is used by CIAO, for example.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.surface_brightness-Tuple{Union{Unitful.Quantity{T, ùêã, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã, U}} where {L, S}} where {T, U}, Function, Function, Float64, Union{Unitful.Quantity{T, ùêã, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã, U}} where {L, S}} where {T, U}, Any, Union{Unitful.Quantity{T, ùêÄ, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêÄ, U}} where {L, S}} where {T, U}}","page":"Internals","title":"BayesJ.surface_brightness","text":"surface_brightness(projected_radius, temperature, density, z, limit, model, pixel_edge_length)\n\nCalculate the observed surface_brightness at some projected radius on the sky.\n\nThe temperature and density functions should take the true distance from origin (cluster centre) and return the appropriate value, with units. The limit controls limits on LOS radius during integration. Theoretically it should be ¬±infinity, but we may approximate it as a finite value. The pixel edge length is the distance observed on the sky, determined from the pixeledgeangle at source redshift.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.XS_Mekal","page":"Internals","title":"BayesJ.XS_Mekal","text":"Mekal model using SpectralFitting.jl framework. Kept around so we can borrow the model data downloading functions.\n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.call_mekal-Tuple{Any, Any, Any}","page":"Internals","title":"BayesJ.call_mekal","text":"call_mekal(energy_range, temperature, nH)\n\nGiven a unitful range of energy and unitless temperature (keV) and hydrogen density in the source (cm^-3) calls MEKAL to calculate the volume emissivity of the source in the source frame.\n\nDue to performance concerns I recommend calling prepare_model_mekal instead to generate an interpolation over the model. The interpolation also implicitly includes absorption, which this function does not.\n\nImplementation Details\n\nThe XSPEC and MEKAL documentation is at times short on detail. Here's what I've figured out, mostly by inspecting the models in the XSPEC source code. The MEKA model has similar code and more extensive comments that MEKAL  that are very helpful.\n\nThe values calculated by MEKAL are multiplied by a constant of 2.53325e-3. Inspecting the MEKA comments we find the following equation for this constant which we will term C\n\nC = 2  h^2  Œ±^3  ((3œÄm_e)^15  (1000e)  œÄ  (1pc)^2  10^4)\n\nand the instruction to use SI units. h appears to be Planck's constant (unreduced) and Œ± the fine-structure constant. Calculating this gives C=2.533242122484874e-59 kg^1/2 m^2 A^-1/2 s^-5/2.\n\nMEKAL adjusts emissions by what it terms cem which is the emitting volume divided by the square of distance to the volume. This follows naturally from the relationship between surface emissivity œÉ and volume emissivity œµ.\n\n    œÉ = œµV  (4œÄD)^2\n\nMEKAL uses units of 1e50cm^3 / 1pc^2 for cem. If we multiply by 10^50cm^3 we get 2.533242122484874e-13 J^2 cm s^2 C^-1/2 kg^-3/2. As dividing by 1pc^2 would change more than just the magnitude of the value I assume it is folded in as the 1pc^2 in the original equation. Furthermore I assume that remaining difference rests in the details of units and implementation.\n\nMEKAL states it outputs in phot/cm^2/s/keV. MEKA states the same but has an optional switch that instead outputs in phot/m^3/s/keV. It does this by replacing C with D=3.03103E-9 which it states is derived so that\n\nC = D * 10^40  (4œÄ * 1pc^2)\n\nI have verified this gives results matching that of doing the conversion manually (by dividing out 1e50cm^3 and multiplying by 1pc^2).\n\nAttempts were made to invoke MEKAL through XSPEC's wrapper functions but I found the modifications they introduced were troublesome to work out, though some were necessary and are reimplemented in surface_brightness. MEKAL's operations are more clearly physically motivated.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.prepare_model_mekal-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Union{Unitful.Quantity{T, ùêã^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã^-2, U}} where {L, S}} where {T, U}, AbstractRange{T}, Real}} where {T<:(Union{Unitful.Quantity{T, ùêã^2 ùêå ùêì^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã^2 ùêå ùêì^-2, U}} where {L, S}} where {T, U}), U<:(Union{Unitful.Quantity{T, ùêã^2 ùêå ùêì^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã^2 ùêå ùêì^-2, U}} where {L, S}} where {T, U}), V<:(Union{Unitful.Quantity{T, ùêã^-3, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã^-3, U}} where {L, S}} where {T, U})}","page":"Internals","title":"BayesJ.prepare_model_mekal","text":"prepare_model_mekal(nHcol, energy_bins, z; temperatures, hydrogen_densities)\n\nCreate an interpolated alias to the mekal model with photoelectric absorption over specified parameter ranges.\n\nThe interpolation object (T::Unitful.Energy, nH::Unitful.ùêã^-3) -> volume emissivity returned gives the volume emissivity per bin of a source of the specified temperature and hydrogen number density with the effects of absorption from passage through an area with a hydrogen column density equal to that specified in the prepare_model_mekal call.\n\nApplies redshift and time dilation.\n\nInterpolation has a significant performance improvement over calling the model directly. No redshift is currently applied to energy bins - they should be assumed to be in the source frame. It may be wise to adjust this but then surface_brightness will need adjustment so it doesn't apply the correction twice.\n\n\n\n\n\n","category":"method"},{"location":"private/#IO","page":"Internals","title":"IO","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Modules = [BayesJ]\nPublic  = false\nPrivate = true\nPages   = [\"io.jl\", \"fitsio_fix.jl\"]","category":"page"},{"location":"private/#BayesJ.Dataset","page":"Internals","title":"BayesJ.Dataset","text":"Abstract type to wrap various specific formats for source data. By doing so we can make use of     multiple dispatch to automatically select the appropriate loading functions for data.\n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.bin_events-Tuple{FITSData, Vararg{Any, 4}}","page":"Internals","title":"BayesJ.bin_events","text":"bin_events(::FITSData, events, energy_range, x_edges, y_edges)\n\nTake a table of events in the format (x y channel energy), trim it by energy and bin it spatially. Returns an array of counts per bin with dimensions (channel, x, y).\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.bin_events-Tuple{PlaintextData, Any, Vararg{Any}}","page":"Internals","title":"BayesJ.bin_events","text":"bin_events(::PlaintextData, events, ...)\n\nPlaceholder function, returns events matrix without modification\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_data-Tuple{BayesJ.Dataset}","page":"Internals","title":"BayesJ.load_data","text":"load_data(data)\n\nLoad events data from a given dataset, returning pairs of events and exposure times.\n\nThe first pair includes all observed events, the second is the background observation.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_data-Tuple{FITSData}","page":"Internals","title":"BayesJ.load_data","text":"load_data(data::FITSData)\n\nLoad data from FITS events files for the observation and background.\n\nExposure times are taken from the LIVETIME value in the header.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_data-Tuple{PlaintextData}","page":"Internals","title":"BayesJ.load_data","text":"load_data(data::PlaintextData)\n\nLoad data from plaintext files as generated by existing Bayes-X binning scripts.\n\nData is reshaped to the given size so should be provided in column-major order or in a matrix of correct size.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_events_from_fits-Tuple{AbstractString}","page":"Internals","title":"BayesJ.load_events_from_fits","text":"load_events_from_fits(path)\n\nLoads events from a single fits file for further processing.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_response-Tuple{BayesJ.Dataset, Any}","page":"Internals","title":"BayesJ.load_response","text":"load_response(data, energy_range)\n\nLoad the RMF and ARF for an observation, trimmed for the desired energy range\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_response-Tuple{PlaintextData, Any}","page":"Internals","title":"BayesJ.load_response","text":"load_response(data::PlaintextData, _)\n\nLoad response matrix from plaintext files as generated by existing Bayes-X binning scripts.\n\nData is reshaped to the given size so should be provided in column-major order or as a matrix of correct size.\n\n\n\n\n\n","category":"method"},{"location":"private/#Likelihood","page":"Internals","title":"Likelihood","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Modules = [BayesJ]\nPublic  = false\nPrivate = true\nPages   = [\"likelihood.jl\"]","category":"page"},{"location":"private/#BayesJ.Prior","page":"Internals","title":"BayesJ.Prior","text":"Abstract supertype for priors. Should implement a transform(prior, x) function that Transforms a value x on the unit range to a value on the distribution represented by the prior.\n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.log_factorial-Tuple{N} where N<:Integer","page":"Internals","title":"BayesJ.log_factorial","text":"log_factorial(n)\n\nFinds the natural logarithm of the factorial of n.\n\nn rapidly gets to large to quickly and directly calculate the factorial so we exploit logarithm rules to expand it out to a series of sums.\n\nIt is intended to be broadcast across all values of the data array.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.log_likelihood-NTuple{5, Any}","page":"Internals","title":"BayesJ.log_likelihood","text":"log_likelihood(observed, observed_background, predicted, predicted_background, observed_log_factorial)\n\nCalculate the log-likelihood of the prediction given an observation.\n\nThe observed and predicted arrays include background events. Log factorial is calculated as ln(observed) + ln(observed_background). We require it to be supplied to improve performance - no need to calculate it every time.\n\nWe assume the predicted_background is scaled to the same exposure time as the observed background.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.make_cube_transform-Tuple{Vararg{BayesJ.Prior}}","page":"Internals","title":"BayesJ.make_cube_transform","text":"make_cube_transform(priors::Prior...)\n\nTurn a sequence of prior transform functions intoNorma a transform function that operates on the hypercube generated by multinest.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.transform-Tuple{BayesJ.Prior, Real}","page":"Internals","title":"BayesJ.transform","text":"transform(prior, x)\n\nTransforms a value x on the unit range to a value on the distribution represented by the prior.\n\n\n\n\n\n","category":"method"},{"location":"private/#Utilities","page":"Internals","title":"Utilities","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Modules = [BayesJ]\nPublic  = false\nPrivate = true\nPages   = [\"mpi.jl\", \"run.jl\"]","category":"page"},{"location":"public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Modules = [BayesJ]\nPublic  = true\nPrivate = false","category":"page"},{"location":"public/#BayesJ.DeltaPrior","page":"Public","title":"BayesJ.DeltaPrior","text":"A delta prior that always returns a constant value.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.FITSData","page":"Public","title":"BayesJ.FITSData","text":"Store a collection of observation data from fits files.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.LogUniformPrior","page":"Public","title":"BayesJ.LogUniformPrior","text":"A log uniform prior that draws from a distribution between min and max whose base 10 logarithm is uniformly distributed.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.PlaintextData","page":"Public","title":"BayesJ.PlaintextData","text":"Store preprocessed data from plaintext files with whitespace delimiters. This data is assumed to have the appropriate binning and energy ranges already applied.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.UniformPrior","page":"Public","title":"BayesJ.UniformPrior","text":"A uniform prior that draws from a uniform distribution between min and max.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.sample-Union{Tuple{T}, Tuple{T, T, Matrix, Function, Union{Unitful.Quantity{T, ùêì, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêì, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, ùêì, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêì, U}} where {L, S}} where {T, U}, Real}} where T<:AbstractArray","page":"Public","title":"BayesJ.sample","text":"sample(observed, observed_background, response_function, transform, obs_exposure_time, bg_exposure_time, redshift; emission_model, pixel_edge_angle, background_rate, average_effective_area)\n\nConfigure some necessary variables and launch ultranest.\n\nThe observed array includes the background.\nThe response function includes both the RMF and ARF, as described in apply_response_function.\nThe emission model should be a function compatible with the requirements of the surface_brightness function, which it will be passed to.\nThe pixel edge angle describes the angular size observed by a single pixel in units such as arcseconds.\n\nThis area is assumed to be square with the edge angle giving the side length.\n\nThe average effective area is the effective area of the telescope averaged across energies,\n\nused with the total background rate across all channels (counts per unit telescope area per sky angle per second)  to calculate the background counts per second per channel per pixel.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.sample-Union{Tuple{U}, Tuple{T}, Tuple{BayesJ.Dataset, AbstractRange{T}, AbstractVector{U}, Union{Unitful.Quantity{T, ùêã^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã^-2, U}} where {L, S}} where {T, U}, Real}} where {T<:(Union{Unitful.Quantity{T, ùêã^2 ùêå ùêì^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã^2 ùêå ùêì^-2, U}} where {L, S}} where {T, U}), U<:BayesJ.Prior}","page":"Public","title":"BayesJ.sample","text":"sample(data::Dataset, energy_range, priors, nhCol, redshift)\n\nRun Bayesian inference on a given set of data, considering only the selected energy range. An gas emission model (density, temperature) ‚Üí emissivity can be provided.\n\n\n\n\n\n","category":"method"},{"location":"#BayesJ.jl-Documentation","page":"Home","title":"BayesJ.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
