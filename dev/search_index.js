var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Anders, E. and Grevesse, N. (1989). Abundances of the Elements: Meteoritic and Solar. Geochimica et Cosmochimica Acta 53, 197–214. Accessed on Jul 23, 2023.\n\n\n\nOlamaie, M.; Feroz, F.; Grainge, K. J.; Hobson, M. P.; Sanders, J. S. and Saunders, R. D. (2015). BAYES-X: A Bayesian Inference Tool for the Analysis of X-ray Observations of Galaxy Clusters. Monthly Notices of the Royal Astronomical Society 446, 1799–1819.\n\n\n\nOlamaie, M.; Hobson, M. P. and Grainge, K. J. (2012). A Simple Parametric Model for Spherical Galaxy Clusters. Monthly Notices of the Royal Astronomical Society 423, 1534–1543.\n\n\n\nVikhlinin, A.; Kravtsov, A.; Forman, W.; Jones, C.; Markevitch, M.; Murray, S. S. and Van Speybroeck, L. (2006). Chandra Sample of Nearby Relaxed Galaxy Clusters: Mass, Gas Fraction, and Mass-Temperature Relation. The Astrophysical Journal 640, 691–709. Accessed on Aug 7, 2023.\n\n\n\n","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"We'll going to walkthrough the construction of an analysis script like in examples/example.jl.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"First we need to import our dependencies.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using BayesJ\nusing Unitful, DimensionfulAngles","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you want to enable debug output add","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ENV[\"JULIA_DEBUG\"] = \"BayesJ\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now we want to load our data. Loading data from a Chandra-style events file is recommended but you can also try PlaintextData","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"data = FITSData(\n    \"data/tng/tng_projections/tng_s67_h11_x_obs_evt.fits\",\n    \"data/tng/tng_projections/tng_s67_h11_x_bg.fits\",\n    \"data/tng/acisi_aimpt_cy0.arf\",\n    \"data/tng/acisi_aimpt_cy0.rmf\",\n    0.492u\"arcsecondᵃ\"\n)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here we have the source and background events, the ARF and RMF and the pixel size. The fancy ᵃ in the units for the pixel size denotes a dimensionful angle. You can get it by typing \\^a in the Julia REPL (or VSCode if you have the Julia extension).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now we want to define our priors.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"priors_nfw = [\n    UniformPrior(\"x0\", -100.0, 100.0),\n    UniformPrior(\"y0\", -100.0, 100.0),\n    UniformPrior(\"MT_500\", 1.0e14, 1.0e15),\n    NormalPrior(\"fg_500\", 0.13, 0.01),\n    UniformPrior(\"c_500\", 3.0, 10.0),\n    DeltaPrior(\"a\", 1.0510),\n    DeltaPrior(\"b\", 5.4905),\n    DeltaPrior(\"c\", 0.3081),\n    DeltaPrior(\"c_500_GNFW\", 1.177)\n]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The first two priors should always be called x0 and y0 (or x and y). They denote the cluster centre position. Other priors can be named whatever you like. These should be one prior for every positional argument to the cluster model. Currently supported priors are DeltaPrior, LogUniformPrior, NormalPrior,UniformPrior and GenericPrior, which can use arbitary distributions.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Finally we call sample.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"sample(\n    data, # our FITSData\n    (0.3u\"keV\", 4.0u\"keV\"), # (minimum energy, maximum energy)\n    Model_NFW, # model function\n    priors_nfw, # list of prior objects\n    0.022e22u\"cm^-2\", # hydrogen column density\n    0.5, # redshift\n    (1900, 2800), # bounds on x in physical pixels\n    (1900, 2800); # bounds on y in phyiscal pixels\n    # everything below is optional\n    bin_size=10, # bin size of spatial pixels (along each axis)\n    centre_radius=0, # binned pixel radius around centre that will be excluded\n    use_interpolation=false, # use interpolation in MEKAL emission calculations. Memory hungry\n    use_stepsampler=false, # use stepsampler to improve efficency\n    mask=\"data/tng/wavedetect.reg\" # path to ciao style mask file. Ellipses only.\n)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The available models are described in Cluster Models.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"tip: Tip\nBayes-X can be run with MPI using the standard MPI methods.mpiexec julia --color=yes --project=@. script.jl@. determines the Julia environment from the working directory. You may also specify a path to the environment - see the command help.. The colour flag is optional but recommended for interactive use - it simply forces coloured terminal output. It is generally desirable to have 1/e processes where e is the expected sampling efficiency.","category":"page"},{"location":"private/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"private/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Pages = [\"private.md\"]","category":"page"},{"location":"private/#Private-Interface","page":"Internals","title":"Private Interface","text":"","category":"section"},{"location":"private/","page":"Internals","title":"Internals","text":"Modules = [BayesJ]\nPublic  = false\nPrivate = true","category":"page"},{"location":"private/#BayesJ.cosmo","page":"Internals","title":"BayesJ.cosmo","text":"Cosmology assumed by BayesX\n\nDefaults to:\n\nh=0.69,\nNeff=3.04,\nOmegaK=0,\nOmegaM=0.29,\nOmegaR=nothing,\nTcmb=2.7255,\nw0=-1,\nwa=0\n\n\n\n\n\n","category":"constant"},{"location":"private/#BayesJ.μ","page":"Internals","title":"BayesJ.μ","text":"Mean mass per gas particle = 0.6mₚ\n\n\n\n\n\n","category":"constant"},{"location":"private/#BayesJ.μ_e","page":"Internals","title":"BayesJ.μ_e","text":"Mean gas mass per electron = 1.14mₚ\n\n\n\n\n\n","category":"constant"},{"location":"private/#BayesJ.Dataset","page":"Internals","title":"BayesJ.Dataset","text":"Abstract type to wrap various specific formats for source data. By doing so we can make use of     multiple dispatch to automatically select the appropriate loading functions for data.\n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.Ellipse","page":"Internals","title":"BayesJ.Ellipse","text":"Ellipse(x, y, r1, r2, θ)\n\nAn ellipse centered at (x, y) with radii r1 and r2 and rotation θ.\n\nr1 and r2 are the width and height respectively with zero rotation and θ is defined as rotation counterclockwise from the x-axis in radians.\n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.LinearInterpolator","page":"Internals","title":"BayesJ.LinearInterpolator","text":"LinearInterpolator(x, y)\n\nConstruct a linear interpolator for the given data.\n\nBoundary behaviour\n\nIf x is below the minimum value of x in the data it is rounded up the the minimum. This results in a flat line below the minimum value of x. In the cluster context this means the core properties may be constant below a certain radius. To avoid this simply fix the smallest value of x` at zero.\n\nIf x is above the maximum value of x in the data the interpolator returns zero. This is because the density and temperature are assumed to be zero outside the cluster. Fix the density and temperature at your largest radius to zero if you wish to avoid a discontinuity here.\n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.ObservationError","page":"Internals","title":"BayesJ.ObservationError","text":"ObservationError(likelihood)\n\nThis wraps a fallback likelihood value so it can be passed up the chain on an invalid prior combination.\n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.Prior","page":"Internals","title":"BayesJ.Prior","text":"Abstract supertype for priors. Should implement:\n\nA transform(prior, x) function that transforms a value x on the unit range to a value on the distribution represented by the prior.\nA field name<:AbstractString \n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.XS_Mekal","page":"Internals","title":"BayesJ.XS_Mekal","text":"Mekal model using SpectralFitting.jl framework. Kept around so we can borrow the model data downloading functions.\n\n\n\n\n\n","category":"type"},{"location":"private/#BayesJ.apply_response_function-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, T}} where T<:AbstractFloat","page":"Internals","title":"BayesJ.apply_response_function","text":"apply_response_function(counts_per_bin::Vector, response::Matrix, exposure_time::Unitful.Time)::Vector{Float64}\n\nApplies the response function RSP(PI E) = RMF(PI E)  ARF(E) to all energy bins and returns adjusted counts per bin.\n\nbeginaligned\nC(PI) = T int RMF(PI E)  ARF(E)  S(E)  dE \n T sum_j R_ij A_j S_j\nendaligned\n\nwith C(PI) is the observed counts in a detector channel PI, T is the observation time, ARF(E) is the effective area of the instrument and RMF(E, PI) [we use RMF(PI, E)] is the unitless response matrix. S(E) is the source flux, in [photon count]/[time]/[area]/[energy]. (Handbook of X-ray Astronomy Chapter 2011, Chapter 5 pg 87, by K. Arnaud, R. Smith and A. Siemiginowska)\n\nThis function takes the combined RMF and ARF as the response function. This is to recalculating it on every call. Some people format the RMF as RMF(E, PI), others as RMF(PI, E). This latter convention is used by CIAO and by us.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.bin_events-Tuple{BayesJ.Dataset, Any, Vararg{Any}}","page":"Internals","title":"BayesJ.bin_events","text":"bin_events(::Dataset, events, ...)\n\nPlaceholder function, returns events matrix without modification\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.bin_events-Tuple{FITSData, Any, Tuple{var\"#s1316\", var\"#s1316\"} where var\"#s1316\"<:Integer, Any, Any}","page":"Internals","title":"BayesJ.bin_events","text":"bin_events(::FITSData, events, energy_range, x_edges, y_edges)\n\nTake a table of events in the format (x y channel), trim it by energy and bin it spatially. Returns an array of counts per bin with dimensions (channel, x, y).\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.bin_events-Tuple{PlaintextData, Any, Vararg{Any}}","page":"Internals","title":"BayesJ.bin_events","text":"bin_events(::PlaintextData, events, ...)\n\nPlaceholder function, returns events matrix without modification\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.call_mekal-Union{Tuple{V}, Tuple{Vector{Float32}, Vector{Float32}, Integer, V, V, V, Float32, Float32}} where V<:AbstractVector{Float32}","page":"Internals","title":"BayesJ.call_mekal","text":"call_mekal(n_energy_bins, abundances, min_energy, max_energy, bin_sizes, temperature, nH)\n\nGiven a unitful range of energy and unitless temperature (keV) and hydrogen density in the source (cm^-3) calls MEKAL to calculate the volume emissivity of the source in the source frame.\n\nResult is in photons/m^3/s/bin.\n\nMetal abundances are set by abundances. They include H, He, C, N, O, Ne, Na, Mg, Al, Si, S, Ar, Ca, Fe and Ni and are specified with respect to solar values. MEKAL uses the solar values from (Anders and Grevesse, 1989).\n\nDue to performance concerns I recommend calling prepare_model_mekal instead to generate an interpolation over the model. The functions returned by that wrapper also implicitly include absorption, which this function does not.\n\nImplementation Details\n\nThe XSPEC and MEKAL documentation is at times short on detail. Here's what I've figured out, mostly by inspecting the models in the XSPEC source code. The MEKA model has similar code and more extensive comments that MEKAL  that are very helpful.\n\nThe values calculated by MEKAL are multiplied by a constant of 2.53325e-3. Inspecting the MEKA comments we find the following equation for this constant which we will term C\n\nC = 2  h^2  α^3  ((3πm_e)^15  (1000e)  π  (1pc)^2  10^4)\n\nand the instruction to use SI units. h appears to be Planck's constant (unreduced) and α the fine-structure constant. Calculating this gives C=2.533242122484874e-59 kg^1/2 m^2 A^-1/2 s^-5/2.\n\nMEKAL adjusts emissions by what it terms cem which is the emitting volume divided by the square of distance to the volume. This follows naturally from the relationship between surface emissivity σ and volume emissivity ϵ.\n\n    σ = ϵV  (4πD)^2\n\nMEKAL uses units of 1e50cm^3 / 1pc^2 for cem. If we multiply by 10^50cm^3 we get 2.533242122484874e-13 J^2 cm s^2 C^-1/2 kg^-3/2. As dividing by 1pc^2 would change more than just the magnitude of the value I assume it is folded in as the 1pc^2 in the original equation. Furthermore I assume that remaining difference rests in the details of units and implementation.\n\nMEKAL states it outputs in phot/cm^2/s/keV. MEKA states the same but has an optional switch that instead outputs in phot/m^3/s/keV. It does this by replacing C with D=3.03103E-9 which it states is derived so that\n\nC = D * 10^40  (4π * 1pc^2)\n\nI have verified this gives results matching that of doing the conversion manually (by dividing out 1e50cm^3 and multiplying by 1pc^2).\n\nAttempts were made to invoke MEKAL through XSPEC's wrapper functions but I found the modifications they introduced were troublesome to work out, though some were necessary and are reimplemented in surface_brightness. MEKAL's operations are more clearly physically motivated.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.cluster","page":"Internals","title":"BayesJ.cluster","text":"Cluster pixels from blobs\n\n\n\n\n\n","category":"function"},{"location":"private/#BayesJ.find_blobs_2D-Union{Tuple{T}, Tuple{AbstractMatrix{T}, T, Any, Any}} where T","page":"Internals","title":"BayesJ.find_blobs_2D","text":"Find blobs in a 2D matrix\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.fit_ellipse-Tuple{Matrix}","page":"Internals","title":"BayesJ.fit_ellipse","text":"Fit an ellipse to a set of pixels\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.getellipsepoints-Tuple{BayesJ.Ellipse}","page":"Internals","title":"BayesJ.getellipsepoints","text":"Get points from the boundry of the ellipse\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_data-Tuple{BayesJ.Dataset}","page":"Internals","title":"BayesJ.load_data","text":"load_data(data)\n\nLoad events data from a given dataset, returning pairs of events and exposure times.\n\nThe first pair includes all observed events, the second is the background observation.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_data-Tuple{FITSData}","page":"Internals","title":"BayesJ.load_data","text":"load_data(data::FITSData)\n\nLoad data from FITS events files for the observation and background.\n\nExposure times are taken from the LIVETIME value in the header.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_data-Tuple{PlaintextData}","page":"Internals","title":"BayesJ.load_data","text":"load_data(data::PlaintextData)\n\nLoad data from plaintext files as generated by existing Bayes-X binning scripts.\n\nData is reshaped to the given size so should be provided in column-major order or in a matrix of correct size.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_events_from_fits-Tuple{AbstractString}","page":"Internals","title":"BayesJ.load_events_from_fits","text":"load_events_from_fits(path)\n\nLoads events from a single fits file for further processing.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_mask-Tuple{AbstractString, Any, Any}","page":"Internals","title":"BayesJ.load_mask","text":"load_mask(path, x_edges, y_edges)\n\nTakes a mask file as used by DS9 and x and y edges to bin on. This should match the edges used to bin the data.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_mask-Tuple{BayesJ.Dataset}","page":"Internals","title":"BayesJ.load_mask","text":"load_mask(data)\n\nThe matrix is true for masked pixels.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_response-Tuple{BayesJ.Dataset, Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}}","page":"Internals","title":"BayesJ.load_response","text":"load_response(data, min_energy, max_energy)\n\nLoad the RMF and ARF for an observation, trimmed for the desired energy range\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_response-Tuple{FITSData, Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}}","page":"Internals","title":"BayesJ.load_response","text":"load_response(data::FITSData, min_energy::Unitful.Energy, max_energy::Unitful.Energy)\n\nLoad response function for specified energy range, adjusting it to align with channel edges.\n\nReturns response matrix, energy bins and included channels. Assumes the RMF and ARF are formatted according to the HEASARC OGIP Calibration Memo CAL/GEN/92-002\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.load_response-Tuple{PlaintextData, Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}}","page":"Internals","title":"BayesJ.load_response","text":"load_response(data::PlaintextData)\n\nLoad response matrix from plaintext files as generated by existing Bayes-X binning scripts.\n\nData is reshaped to the given size so should be provided in column-major order or as a matrix of correct size.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.log_factorial-Tuple{N} where N<:Integer","page":"Internals","title":"BayesJ.log_factorial","text":"log_factorial(n)\n\nFinds lnn the natural logarithm of the factorial of n.\n\nn rapidly gets to large to quickly and directly calculate the factorial so we exploit logarithm rules to expand it out to a series of sums.\n\nIt is intended to be broadcast across all values of the data array.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.log_likelihood-Tuple{Any, Any, Any}","page":"Internals","title":"BayesJ.log_likelihood","text":"log_likelihood(observed, observed_background, predicted, predicted_background, observed_log_factorial)\n\nCalculate the log-likelihood of the prediction given an observation.\n\nThe observed and predicted arrays include background events.\n\nThe constant likelihood includes all parts of the likelihood that remain constant across observations. We require it to be supplied to improve performance - no need to calculate it every time.  It also includes the log factorial components calculated as ln(observed) + ln(observed_background). As we haven't implemented support for background fitting on the user input side of things this includes the background.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.make_cube_transform-Tuple{Vararg{BayesJ.Prior}}","page":"Internals","title":"BayesJ.make_cube_transform","text":"make_cube_transform(priors::Prior...)::NTuple{2, Function}\n\nTurn a sequence of prior transform functions into a transform function transform_cube that operates on the hypercube generated by multinest, stripping delta functions.\n\nIt also returns a function reconstruct_args take takes the output of the first function and returns it with the values of the delta priors inserted in appropriate postions.  This is because Ultranest can run with delta priors but outputs error warnings in the process.\n\nReturns transform_cube and reconstruct_args as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.make_observation-Union{Tuple{T}, Tuple{A}, Tuple{Any, Any, Real, Tuple{var\"#s423\", var\"#s423\"} where var\"#s423\"<:Integer, A, Any, T, Any, Tuple{Real, Real}, Any}} where {A<:(Union{Unitful.Quantity{T, 𝐀, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐀, U}} where {L, S}} where {T, U}), T<:(Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U})}","page":"Internals","title":"BayesJ.make_observation","text":"make_observation(temperature, density, z, shape, pixel_edge_angle, emission_model, exposure_time, response_function, centre, centre_radius, mask=nothing)\n\nUnitless wrapper for make_observation\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.make_observation-Union{Tuple{T}, Tuple{A}, Tuple{Any, Any, Real, Tuple{var\"#s424\", var\"#s424\"} where var\"#s424\"<:Integer, A, Any, T, AbstractMatrix{<:Union{Unitful.Quantity{T, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2, U}} where {L, S}} where {T, U}}, Tuple{var\"#s426\", var\"#s426\"} where var\"#s426\"<:(Union{Unitful.Quantity{T, 𝐀, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐀, U}} where {L, S}} where {T, U}), Real}} where {A<:(Union{Unitful.Quantity{T, 𝐀, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐀, U}} where {L, S}} where {T, U}), T<:(Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U})}","page":"Internals","title":"BayesJ.make_observation","text":"make_observation(temperature, density, z, shape, pixel_edge_angle, emission_model, exposure_time, response_function, centre, centre_radius, mask=nothing, limit=10u\"Mpc\")\n\nGenerate an image of the cluster given functions for the radial profile of gas temperature and electron density and assorted observational parameters.\n\nshape describes the size of the source number as a number of spatial bins in each dimension.-\nThe pixel edge angle describes the angular size observed by a single pixel in units such as arcseconds. This area is assumed to be square with the edge angle giving the side length.\nThe emission model should be a function compatible with the requirements of the surface_brightness function, which it will be passed to.\nThe response function includes both the RMF and ARF, as described in apply_response_function.\nThe limit is passed through to surface_brightness\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.pixel_offset-Tuple{Any, Any, Any}","page":"Internals","title":"BayesJ.pixel_offset","text":"pixel_offset(ij, array_centre_indices, centre_offset_pixels)\n\nCalculate the distance from the centre of the cluster to the pixel at indices ij.\n\nResult in pixels.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.surface_brightness-Tuple{Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Any, Any, Float64, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Function, Union{Unitful.Quantity{T, 𝐀, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐀, U}} where {L, S}} where {T, U}, Vector{Float32}}","page":"Internals","title":"BayesJ.surface_brightness","text":"surface_brightness(projected_radius, temperature, density, z, limit, model, pixel_edge_angle)\n\nCalculate the observed surface_brightness at some projected radius on the sky.\n\nThe temperature and density functions should take the distance from origin (cluster centre) and return the appropriate value, with units.\n\nThe model should take these functions as input and return a vector of volume emissivities, where the vector element correspond with the energy bins used to generate the mode. It should include the effects of redshift on the bins and time dilation on the count rate.\n\nThe limit controls limits on LOS radius during integration. Testing suggests that Inf (default) is faster than finite values >1. However finite values may avoid problems with models that are badly behaved at large radii.\n\nThe pixel edge angle is the angular size of a single pixel.\n\nThe result returned is the expected count rate per unit observing area, as a vector corresponding to the energy bins as used in the model.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.test_point-Tuple{BayesJ.Ellipse, Any, Any}","page":"Internals","title":"BayesJ.test_point","text":"test_point(e::Ellipse, x, y; atol=0)\n\nTests whether a point is within an ellipse with tolerance atol.\n\nThe equation for an ellipse in Cartesian coordinates is of the form f(x,y) = 1. We consider any point (x0, y0) such that f(x0, y0) <= 1 + atol as being within the ellipse.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.transform-Tuple{BayesJ.Prior, Real}","page":"Internals","title":"BayesJ.transform","text":"transform(prior, x)\n\nTransforms a value x on the unit range to a value on the distribution represented by the prior.\n\n\n\n\n\n","category":"method"},{"location":"private/#BayesJ.ρ_crit-Tuple{Any}","page":"Internals","title":"BayesJ.ρ_crit","text":"p_crit(z)\n\nCalculate the critical density at some redshift z.\n\n\n\n\n\n","category":"method"},{"location":"models/#cluster_models_page","page":"Cluster Models","title":"Cluster Models","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"When setting up sampling the user must supply a cluster model function to the sample function. This model takes a set of parameters (typically drawn from the priors) and returns two functions for the gas temperature and gas mass density as a function of radius.","category":"page"},{"location":"models/#Included-Models","page":"Cluster Models","title":"Included Models","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"BayesJ has three cluster models included. These are the Model_NFW, Model_Einasto and Model_Vikhlinin2006.","category":"page"},{"location":"models/#NFW","page":"Cluster Models","title":"NFW","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The NFW model Model_NFW assumes the dark matter density profile follows the Navarro–Frenk–White profile and the electron pressure profile follows the generalised NFW model.","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"This model is derived in (Olamaie et al., 2012). In additional to the aforementioned profiles it assumes","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The cluster is spherical\nThe ICM is in hydrostatic equilbrium\nThe ICM is an ideal gas\nThe local gas fraction (gas mass / total mass) is much less than unity at all radii.","category":"page"},{"location":"models/#Parameters","page":"Cluster Models","title":"Parameters","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The following parameters can be investigated with priors.","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"Parameter Definition\nMT_Δ Total mass within the overdensity radius R_Δ\nfg_Δ Gas fraction at R_Δ\ncΔdm NFW concentration parameter\nα GNFW parameter\nβ GNFW parameter\nγ GNFW parameter\ncΔGNFW GNFW gas concentration parameter","category":"page"},{"location":"models/#Einasto","page":"Cluster Models","title":"Einasto","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The Einasto model Model_Einasto assumes the dark matter density profile follows the Einasto profile and the gas pressure profile follows the generalised NFW model.","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"This model makes the same assumptions as the NFW model but subsitutes the Einasto profile in place of the NFW profile for dark matter density.","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"This model is derived in (Olamaie et al., 2015).","category":"page"},{"location":"models/#Parameters-2","page":"Cluster Models","title":"Parameters","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The following parameters can be investigated with priors.","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"Parameter Definition\nMT_Δ Total mass within the overdensity radius R_Δ\nfg_Δ Gas fraction at R_Δ\ncΔdm NFW concentration parameter\nn Einasto index\nα GNFW parameter\nβ GNFW parameter\nγ GNFW parameter\nc_Δ_GNFW GNFW gas concentration parameter","category":"page"},{"location":"models/#Vikhlinin-2006","page":"Cluster Models","title":"Vikhlinin 2006","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The Model_Vikhlinin2006 is the model used by Vikhlinin et al. in an analysis of Chandra observations (Vikhlinin et al., 2006).","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"This model is highly flexible, featuring independent equations for gas number density profile and gas temperature profile.","category":"page"},{"location":"models/#Parameters-3","page":"Cluster Models","title":"Parameters","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The following parameters can be investigated with priors.","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"Parameter Equation Definition\nn0 Density Number density normalisation\nn02 Density Number density normalisation of core term\nα Density Dimensionless parameter\nβ Density Dimensionless parameter\nβ2 Density Dimensionless parameter\nϵ Density Dimensionless parameter\nrc Density Scale radius\nrc2 Density Scale radius of core term\nrs Density Scale radius\nT0 Temperature Temperature normalisation\nTminT0 Temperature Ratio of Tmin to T0\nrcool Temperature Scale radius\nacool Temperature Dimensionless parameter\nrt Temperature Scale radius\na Temperature Dimensionless parameter\nb Temperature Dimensionless parameter\nc Temperature Dimensionless parameter","category":"page"},{"location":"models/#Custom-Models","page":"Cluster Models","title":"Custom Models","text":"","category":"section"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The user can easily subsitute a custom model. It should be a function that will take a sequence of parameters associated with the priors as positional arguements and accept the keyword argument z for redshift. This value can then be ignored if it is of no consequence to the model as is the case in Model_Vikhlinin2006. As UltraNest cannnot accept priors with units a version of the function may need to be provided to handle cases with/without units.","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The function should return two functions, for gas temperature and gas mass density. Each function should take a single arguement: radius (on the sky) with respect to the cluster center. They should return a single scalar value for the associated property. Both the radius and output should have appropriate units using the system implemented by Unitful.jl. The temperature should be in units of energy  (so more strictly it is k_B T).","category":"page"},{"location":"models/","page":"Cluster Models","title":"Cluster Models","text":"The priorcheck function is provided to help with applying constraints to input priors during sampling.","category":"page"},{"location":"public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Modules = [BayesJ]\nPublic  = true\nPrivate = false","category":"page"},{"location":"public/#BayesJ.DeltaPrior","page":"Public","title":"BayesJ.DeltaPrior","text":"DeltaPrior(name::AbstractString, value::Number)\n\nA delta prior that always returns a constant value.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.DependentLogUniformPrior","page":"Public","title":"BayesJ.DependentLogUniformPrior","text":"DependentLogUniformPrior(name::AbstractString, depends_on::AbstractString, range::Number)\n\nGenerates a dependent log uniform prior.\n\nThe dependent prior has a minimum value equal to that of the parent prior and a maximum value equal to the parent prior plus the range. By specifying a negative range, the dependent prior can be made to have a maximum value less than the parent prior.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.DependentUniformPrior","page":"Public","title":"BayesJ.DependentUniformPrior","text":"DependentUniformPrior(name::AbstractString, depends_on::AbstractString, range::Number)\n\nGenerates a dependent uniform prior.\n\nThe dependent prior has a minimum value equal to that of the parent prior and a maximum value equal to the parent prior plus the range. By specifying a negative range, the dependent prior can be made to have a maximum value less than the parent prior.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.FITSData","page":"Public","title":"BayesJ.FITSData","text":"FITSData(observation::AbstractString, background::AbstractString, arf::AbstractString, rmf::AbstractString, pixel_edge_angle::DimensionfulAngles.Angle)\n\nStore a collection of observation data from fits files.\n\nTakes paths to the files as inputs.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.GenericPrior","page":"Public","title":"BayesJ.GenericPrior","text":"GenericPrior(name::AbstractString, dist::Distributions.UnivariateDistribution)\n\nA generic prior that draws from the specified distribution.\n\nSee Distributions.jl for a list of avaliable distributions.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.LogUniformPrior","page":"Public","title":"BayesJ.LogUniformPrior","text":"LogUniformPrior(name::AbstractString, min::Number, max::Number)\n\nA log uniform prior that draws from a distribution between min and max whose base 10 logarithm is uniformly distributed.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.NormalPrior","page":"Public","title":"BayesJ.NormalPrior","text":"NormalPrior(name::AbstractString, mean::Number, σ::Number)\n\nA normal prior that draws from a Gaussian/normal distribution with mean and standard deviation σ.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.PlaintextData","page":"Public","title":"BayesJ.PlaintextData","text":"PlaintextData(observation::AbstractString, background::AbstractString, arf::AbstractString, rmf::AbstractString, shape::NTuple{3,Int}, rmf_shape::NTuple{2,Int}, obs_exposure_time::Unitful.Time, bg_exposure_time::Unitful.Time, pixel_edge_angle::DimensionfulAngles.Angle, rmf_unit::Unitful.Area)\n\nStore preprocessed data from plaintext files with whitespace delimiters.\n\nEvents and response files provided as paths. This data is assumed to have the appropriate binning and energy ranges already applied. The shape of the event arrays should be (channels, x, y) and the rmf_shape should be (channels, bins).\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.PriorError","page":"Public","title":"BayesJ.PriorError","text":"PriorError(likelihood)\n\nThis wraps a fallback likelihood value so it can be passed up the chain on an invalid prior combination.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.UniformPrior","page":"Public","title":"BayesJ.UniformPrior","text":"UniformPrior(name::AbstractString, min::Number, max::Number)\n\nA uniform prior that draws from a uniform distribution between min and max.\n\n\n\n\n\n","category":"type"},{"location":"public/#BayesJ.Model_Constant-Tuple{Real, Real, Real}","page":"Public","title":"BayesJ.Model_Constant","text":"Model_Constant(T::Unitful.Energy, ρ::Unitful.Density; kwargs...)\n\nUnitless wrapper for Model_Constant\n\nRadius is in Mpc, temperature is in keV, density is in g/cm^3\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.Model_Constant-Tuple{Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐌 𝐋^-3, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-3, U}} where {L, S}} where {T, U}}","page":"Public","title":"BayesJ.Model_Constant","text":"Model_Constant(radius::Unitful.Length, T::Unitful.Energy, ρ::Unitful.Density; kwargs...)\n\nConstant temperature and density model in sphere of given radius.\n\nIntended for testing purposes.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.Model_Einasto-Tuple{Real, Vararg{Any, 7}}","page":"Public","title":"BayesJ.Model_Einasto","text":"Model_Einasto(MT_Δ::Real, fg_Δ, n, α, β, γ, c_Δ_GNFW; z, Δ=500)\n\nUnitless wrapper for Model_Einasto. Mass is in solar masses.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.Model_Einasto-Tuple{Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}, Vararg{Any, 7}}","page":"Public","title":"BayesJ.Model_Einasto","text":"Model_Einasto(MT_Δ::Unitful.Mass, fg_Δ, c_Δ_dm, n, α, β, γ, c_Δ_GNFW; z, Δ=500)\n\nGenerate a cluster profile based on the Einasto mass density profile and the GNFW gas pressure profile.\n\nSee Appendix A of (Olamaie et al., 2015) for a derivation of the model based on these profiles.\n\nReturns functions for gas temperature and gas mass density as a function of radius.\n\nIf 1/n>2 then the gas temperature starts increasing to physically improbable levels (orders exceeding 10¹¹ keV).\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.Model_NFW-Tuple{Real, Vararg{Any, 6}}","page":"Public","title":"BayesJ.Model_NFW","text":"Model_NFW(MT_Δ::Real, fg_Δ, α, β, γ, c_Δ_GNFW; z, Δ=500)\n\nUnitless wrapper for Model_NFW. Mass is in solar masses.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.Model_NFW-Tuple{Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}, Vararg{Any, 6}}","page":"Public","title":"BayesJ.Model_NFW","text":"Model_NFW(MT_Δ::Unitful.Mass, fg_Δ, c_Δ_dm, α, β, γ, c_Δ_GNFW; z, Δ=500)\n\nGenerate a cluster profile based on the NFW mass density and GNFW gas density profiles.\n\nUses the model from (Olamaie et al., 2012), which is based on the NFW dark matter density profile and the GNFW gas pressure profile.\n\nKeyword arguments are redshift and overdensity.\n\nReturns functions for gas temperature and gas mass density as a function of radius.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.Model_Piecewise-Tuple{Vararg{Real}}","page":"Public","title":"BayesJ.Model_Piecewise","text":"Model_Piecewise(radius, density, temperature, radius, density, temperature, ...)\n\nConstruct a piecewise model for the given data.\n\nThe model is constructed by linearly interpolating the given data. See LinearInterpolator for details on the interpolation behaviour.\n\nDensity is assumed to be in units of g/cm^3, temperature in units of keV, and radius in units of kpc.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.Model_Vikhlinin2006","page":"Public","title":"BayesJ.Model_Vikhlinin2006","text":"Model_Vikhlinin2006(n0::NumberDensity, n02::NumberDensity, rc::Unitful.Length, rc2::Unitful.Length, α, β, β2, ϵ, rs::Unitful.Length, T0::Unitful.Energy, TminT0, rcool::Unitful.Length, acool, rt::Unitful.Length, a, b, c; γ=3, kwargs...)\n\nGenerate a cluster profile using the highly free models from (Vikhlinin et al., 2006).\n\nd was introduced to experiment with changing the behaviour of temperature at the core. Leave it at zero that match the original Vikhlinin equations.\n\n\n\n\n\n","category":"function"},{"location":"public/#BayesJ.Model_Vikhlinin2006-Tuple{Real, Real, Real, Real, Any, Any, Any, Any, Real, Real, Any, Real, Any, Real, Vararg{Any, 4}}","page":"Public","title":"BayesJ.Model_Vikhlinin2006","text":"Model_Vikhlinin2006(n0::Real, n02::Real, rc::Real, rc2::Real, α, β, β2, ϵ, rs::Real, T0::Real, TminT0, rcool::Real, acool, rt::Real, a, b, c; γ=3, kwargs...)\n\nUnitless wrapper for Model_Vikhlinin2006. Densities are in cm^-3 and radii are in kpc. Temperature is in keV.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.prepare_model_mekal-Union{Tuple{T}, Tuple{A}, Tuple{Union{Unitful.Quantity{T, 𝐋^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^-2, U}} where {L, S}} where {T, U}, AbstractVector{T}, Real}, Tuple{Union{Unitful.Quantity{T, 𝐋^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^-2, U}} where {L, S}} where {T, U}, AbstractVector{T}, Real, AbstractVector{A}}} where {A<:Real, T<:(Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U})}","page":"Public","title":"BayesJ.prepare_model_mekal","text":"prepare_model_mekal(nHcol, energy_bins, z, [abundances])\n\nGenerate a function to calculate emission with MEKAL .\n\nThe returned function has signature\n\nf!(flux::Vector{Float32}, T::Unitful.Energy, nH::Unitful.𝐋^-3)::Vector{Float32}\n\nIt works inplace on flux. After execution flux contains the volume emissivity in photons per cubic metre per second per bin of  a source of the specified temperature and hydrogen number density. Photon redshift and time dilation effects based on the redshift z.  It also applies the effects of absorption from passage through an area with a hydrogen column density nHcol.\n\nMetal abundances are set by abundances. They include H, He, C, N, O, Ne, Na, Mg, Al, Si, S, Ar, Ca, Fe and Ni and are specified with respect to solar values. MEKAL uses the solar values from (Anders and Grevesse, 1989).\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.prepare_model_mekal_interpolation-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{A}, Tuple{Union{Unitful.Quantity{T, 𝐋^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^-2, U}} where {L, S}} where {T, U}, AbstractVector{T}, Real}, Tuple{Union{Unitful.Quantity{T, 𝐋^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^-2, U}} where {L, S}} where {T, U}, AbstractVector{T}, Real, AbstractVector{A}}} where {A<:Real, T<:(Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}), U<:(Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}), V<:(Union{Unitful.Quantity{T, 𝐌 𝐋^-3, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-3, U}} where {L, S}} where {T, U})}","page":"Public","title":"BayesJ.prepare_model_mekal_interpolation","text":"preparemodelmekalinterpolation(nHcol, energybins, z, [abundances, temperatures, hydrogen_densities])\n\nGenerate an interpolation function to calculate emission with MEKAL.\n\nThis wraps prepare_model_mekal to generate an interpolation function over the model.  Interpolation points are determined from temperatures and hydrogen_densities.\n\nInterpolation has a significant performance improvement over calling the model directly. No redshift is currently applied to energy bins - they should be assumed to be in the source frame. It may be wise to adjust this but then surface_brightness will need adjustment so it doesn't apply the correction twice.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.priorcheck-Tuple{Any, Any}","page":"Public","title":"BayesJ.priorcheck","text":"priorcheck(condition, likelihood)\n\nCheck that a condition holds and fallback to the given likelihood if not.\n\nSimply call this function in your model. If the condition fails a PriorError is raised.\n\nThe likelihood is encapsulated in the PriorError so that a try-catch block in the function calling the model can extract it and return it as the likelihood generated by that prior set without going through observation generation and likelihood calculation.\n\nThe faux likelihood should be chosen to be sufficiently small (e.g. -1e100) that it will not be competing with the likelihood from good parameters. It should also be designed with a slope to point the sampler in the right direction. For instance if  the constraint is that a  b then -1e100 * (1 + (a - b)) would  be good. This constraint ensures the likelihood grows larger when a and b grow closer  together. The additional one ensures that a=b won't set the likelihood to zero.\n\nSee the ultranest documentation  for additional details.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.sample-Tuple{BayesJ.Dataset, Tuple{var\"#s428\", var\"#s428\"} where var\"#s428\"<:(Union{Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {T, U}), Function, AbstractVector{<:BayesJ.Prior}, Union{Unitful.Quantity{T, 𝐋^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^-2, U}} where {L, S}} where {T, U}, Real, Tuple{var\"#s425\", var\"#s425\"} where var\"#s425\"<:Real, Tuple{var\"#s424\", var\"#s424\"} where var\"#s424\"<:Real}","page":"Public","title":"BayesJ.sample","text":"sample(\n    data::Dataset,\n    energy_limits::NTuple{2, Unitful.Energy},\n    cluster_model::Function,\n    priors::AbstractVector{Prior},\n    nhCol::SurfaceDensity,\n    redshift::Real,\n    x::NTuple{2,<:Real},\n    y::NTuple{2,<:Real};\n    bin_size::Real=10,\n    use_interpolation::Bool=false,\n    centre_radius::Int=0,\n    mask=nothing,\n    cache_size::Int64=1000000000\n    )\n\nRun Bayesian inference on a given set of data considering only the selected energy range.\n\nThe cluster model can be any function that takes a set of parameters matching the priors and a z keyword argument, \n\nand returns two functions for the gas temperature and gas mass density as a function of radius.\n\nThe first two priors should always be named \"x0\" and \"y0\", giving cluster centre position (\"x\" and \"y\" are also accepted).\nx and y are tuples of (min, max) in pixels. These crop the observation. Bin size is specified in the same units.\nmask is optional. If included it should be a string pointing to a mask file using CIAO syntax. Only ellipses are supported.\ncentre_radius excludes some radius, in pixels, around the centre from analysis\nAdditional kwargs will be passed through to the next sample function.\n\n\n\n\n\n","category":"method"},{"location":"public/#BayesJ.sample-Union{Tuple{T}, Tuple{T, T, AbstractMatrix, Function, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Real}} where T<:AbstractArray","page":"Public","title":"BayesJ.sample","text":"sample(observed,observed_background, response_function, transform, obs_exposure_time, bg_exposure_time, redshift; prior_names, cluster_model, emission_model, param_wrapper, pixel_edge_angle)\n\nConfigure some necessary variables and launch ultranest.\n\nThe observed array includes the background. The first dimension is energy, the other two are spatial.\nThe response function includes both the RMF and ARF, as described in apply_response_function.\nThe emission model should be a function compatible with the requirements of the surface_brightness function, which it will be passed to.\nThe pixel edge angle describes the angular size observed by a single pixel in units such as arcseconds.\n\nThis area is assumed to be square with the edge angle giving the side length.\n\nThe first two priors should always be \"x0\" and \"y0\", giving cluster centre position and the order of prior_names must match the transform.\nThe cluster model should be a function that takes the parameters (and redshift as a kwarg) and returns (gas_temperature,gas_density) as functions of\n\nradius which return their respective quantities with units.\n\nparam_wrapper takes the output of the transform function and adds any additional arguements necessary for the model.\ncentre_radius, mask and integration_limit are passed through to make_observation\n\n\n\n\n\n","category":"method"},{"location":"#BayesJ.jl-Documentation","page":"Home","title":"BayesJ.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bayesian inference on galaxy clusters in X-ray.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BayesJ is an unregistered Julia package. Install it with","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Infinite-Improbability/BayesX-Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"You will need the AstroRegistry from https://github.com/astro-group-bristol/AstroRegistry.","category":"page"},{"location":"setup/#Setup","page":"Setup","title":"Setup","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"BayesJ is developed for Julia 1.9, which can be obtained from https://julialang.org/. If you're unfamiliar with Julia's package manager go read its getting started guide quickly.","category":"page"},{"location":"setup/#Basic-Installation","page":"Setup","title":"Basic Installation","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"Launch the Julia REPL with","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"shell> julia","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Set the Python environment used by PyCall.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"julia> ENV[\"PYTHON\"]=\"\"","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Press ] to enter the package manager.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"You can (optionally) activate an environment in the current folder. This helps keep dependencies tidy across projects. ","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"pkg> activate .","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Setup the required package registries with","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"pkg> registry add General\npkg> registry add https://github.com/astro-group-bristol/AstroRegistry","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Install BayesJ and all dependencies* with","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"pkg> add https://github.com/Infinite-Improbability/BayesX-Julia","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Done! You can exit the package manager with backspace or Ctrl-C","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"* If you want MPI support see the details below.","category":"page"},{"location":"setup/#Specifying-an-alternate-Python","page":"Setup","title":"Specifying an alternate Python","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"We use PyCall to access Ultranest. This can use your system Python or a seperate minimal distribution and is controlled by the PYTHON environment variable. The PyCall documentation has details here. I recommend PYTHON=\"\", which uses an internal Miniconda distribution.","category":"page"},{"location":"setup/#MPI-Support","page":"Setup","title":"MPI Support","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"Ultranest supports MPI for parallelisation. To use launch your Julia scripts using mpiexec or equivalent.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"While the Python dependencies will install automatically if not found, this can be cause segfaults as MPI.jl is trying to use one MPI library and mpi4py another. I suggest manually installing ultranest and mpi4py in a conda environment. This allows you to use force Conda to use an external MPI library.","category":"page"},{"location":"setup/#MPI-Setup","page":"Setup","title":"MPI Setup","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"Find the Conda environment used by BayesJ with conda env list. This works even if Julia is using an internal Miniconda installation - look for environments with a .julia path and no name. In the example below it is the third environment.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"shell> conda env list\n# conda environments:\n#\nbase                     /trimmed/for/length\nciao                     /nfs/home/coxry/.conda/envs/ciao\n                         ~/.julia/conda/3/x86_64","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Activate the environment with","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"shell> conda activate name/or/path","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Install Ultranest, mpi4py and an appropriate external MPI package, as explained in the Conda documentation. I use OpenMPI. x.y should be replaced with the approriate version number, probably 4.1 for OpenMPI.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"shell> conda install ultranest mpi4py openmpi=x.y.*=external_*","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Then set the MPI library used by Julia. Run this in your shell","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"shell> julia --project -e 'using MPIPreferences; MPIPreferences.use_system_binary()'","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"or this in the REPL","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"julia> using MPIPreferences\njulia> MPIPreferences.use_system_binary()","category":"page"},{"location":"setup/#Installation-for-Development","page":"Setup","title":"Installation for Development","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"If you want to edit the source then you'll want to install it a bit differently.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"First clone the repository. Launch the Julia REPL inside it.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Set the Python executable (as described above)","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"julia> ENV[\"PYTHON\"]=\"\"","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Switch to pkg mode and activate the BayesJ environment.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"pkg> activate .","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Setup the required package registries","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"pkg> registry add General\npkg> registry add https://github.com/astro-group-bristol/AstroRegistry","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"Finally instantiate the environment to install dependencies.","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"pkg> instantiate","category":"page"},{"location":"setup/","page":"Setup","title":"Setup","text":"If you want MPI support the same instructions apply as before.","category":"page"}]
}
