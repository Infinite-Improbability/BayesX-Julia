using Plots

using PyCall
ultranest = pyimport_conda("ultranest", "ultranest", "conda-forge")

include("gas_models.jl")
include("io.jl")

"""
    log_likelihood(observed, observed_background, predicted, predicted_background, observed_log_factorial)

Calculate the log-likelihood of the prediction given an observation.

The observed and predicted arrays include background events.
Log factorial is calculated as `ln(observed) + ln(observed_background)`.
We require it to be supplied to improve performance - no need to calculate it every time.

We assume the predicted_background is scaled to the same exposure time as the observed background.
"""
function log_likelihood(
    observed,
    observed_background,
    predicted,
    predicted_background,
    observed_log_factorial
)
    @debug "Calculating log likelihood"

    @assert size(observed) == size(predicted) "Observations have size $(size(observed)) whereas predictions have size $(size(predicted))"
    @assert size(observed) == size(observed_background)
    @assert size(predicted) == size(predicted_background) || size(predicted_background) == ()


    t1 = @. observed * log(predicted) - predicted
    t2 = @. observed_background * log(predicted_background) - predicted_background

    replace!(t2, NaN => 0) # for some reason log(0) sometimes produces NaN not -Inf

    t = @. t1 + t2 - observed_log_factorial

    # If we have zero counts we can't take the log so
    # we'll just skip over it.
    replace!(t, -Inf => 0, NaN => 0)

    # For some reason 

    @assert all(isfinite, t) display(t)

    return sum(t)
end

"""
    log_factorial(n)

Finds the natural logarithm of the factorial of `n`.

`n` rapidly gets to large to quickly and directly calculate the factorial
so we exploit logarithm rules to expand it out to a series of sums.

It is intended to be broadcast across all values of the data array.
"""
log_factorial(n::N) where {N<:Integer} = sum(log.(1:n))

"""
Abstract supertype for priors. Should implement a transform(prior, x) function that Transforms
a value x on the unit range to a value on the distribution represented by the prior.
"""
abstract type Prior end

"""
    transform(prior, x)

Transforms a value x on the unit range to a value on the distribution represented by the prior.
"""
function transform(prior::Prior, x::Real) end

"""A delta prior that always returns a constant value."""
struct DeltaPrior{T<:Number} <: Prior
    value::T
end
function transform(prior::DeltaPrior, x::Real)
    @argcheck 0 <= x <= 1
    return prior.value
end

"""A uniform prior that draws from a uniform distribton between `min` and `max`."""
struct UniformPrior{T<:Number} <: Prior
    min::T
    max::T
    UniformPrior(min::T, max::T) where {T<:Number} = max > min ? new{T}(min, max) : error("Maximum is not greater than min")
end
function transform(prior::UniformPrior, x::Real)
    return x * (prior.max - prior.min) + prior.min
end

"""
    make_cube_transform(priors::Prior...)

Turn a sequence of prior transform functions into a transform function that operates
on the hypercube generated by multinest.
"""
function make_cube_transform(priors::Prior...)

    """
        transform_cube(cube)

    Transforms the hypercube used by ultranest into physical prior values.

    Ultranest models priors as a unit hypercube where each dimesion is a unit uniform
    distribution. The transform function converts values on these uniform distributions
    to values on the physical prior distribution. Each column is a specific prior, so each
    row is a complete sample of the set of priors.
    """
    function transform_cube(cube::AbstractArray)
        # MT_200::Unitful.Mass,
        # fg_200,
        # a_GNFW,
        # b_GNFW,
        # c_GNFW,
        # c_500_GNFW,

        @debug "Transform started"

        for (c, p) in zip(axes(cube, 2), priors)
            cube[:, c] = transform.(Ref(p), cube[:, c])
        end

        @debug "Transform done"

        return cube
    end

    return transform_cube
end

"""
    run(observed, observed_background, response_function, transform, obs_exposure_time, bg_exposure_time; emission_model, pixel_edge_angle)

Configure some necessary variables and launch ultranest.

* The observed array includes the background.
* The response function includes both the RMF and ARF, as described in `apply_response_function`.
* The emission model should be a function compatible with the requirements of the `surface_brightness` function, which it will be passed to.
* The pixel edge angle describes the angular size observed by a single pixel in units such as arcseconds.
 This area is assumed to be square with the edge angle giving the side length.
* The average effective area is the effective area of the telescope averaged across energies,
 used with the total background rate across all channels (counts per unit telescope area per sky angle per second)
 to calculate the background counts per second per channel per pixel.
"""
function run(
    observed::T,
    observed_background::T,
    response_function::Matrix,
    transform::Function,
    obs_exposure_time::Unitful.Time,
    bg_exposure_time::Unitful.Time,
    redshift::Real;
    emission_model,
    pixel_edge_angle=0.492u"arcsecond",
    background_rate=8.6e-2u"m^-2/arcminute^2/s",
    average_effective_area=250u"cm^2"
) where {T<:AbstractArray}
    @debug "Preparing for ultranest"

    predicted_bg_rate = background_rate / size(observed)[1] * average_effective_area * pixel_edge_angle^2
    predicted_obs_bg = predicted_bg_rate * obs_exposure_time # Used for adding background to observations
    predicted_bg_bg = predicted_bg_rate * bg_exposure_time # Used for log likelihood

    log_obs_factorial = log_factorial.(observed) + log_factorial.(observed_background)

    @assert all(isfinite, observed)
    @assert all(isfinite, observed_background)
    @assert all(isfinite, log_obs_factorial)

    @assert size(observed) == size(observed_background)

    dshape = [i for i in size(observed)][2:3]

    # a wrapper to handle running the gas model and likelihood calculation
    @debug "Generating likelihood wrapper"
    function likelihood_wrapper(params)
        @debug "Likelihood wrapper called"

        n, _ = size(params)

        params_rows = Vector{Vector{eltype(params)}}(undef, n)
        for i in 1:n
            params_rows[i] = params[i, :]
        end

        predicted = [Model_NFW_GNFW(params_rows[i]...,
            1.062,
            5.4807,
            0.3292,
            1.156,
            redshift,
            dshape,
            pixel_edge_angle,
            emission_model,
            obs_exposure_time,
            response_function
        ) .+ predicted_obs_bg for i in 1:n]


        @debug "Predicted results generated"
        # [display(heatmap(dropdims(sum(p, dims=1), dims=1))) for p in predicted]

        return log_likelihood.(
            Ref(observed),
            Ref(observed_background),
            predicted,
            predicted_bg_bg,
            Ref(log_obs_factorial)
        )
    end

    # ultranest setup
    @debug "Creating sampler"
    paramnames = ["MT_200", "fg_200"] # move to pairs with prior objects?
    sampler = ultranest.ReactiveNestedSampler(
        paramnames,
        likelihood_wrapper,
        transform=transform,
        vectorized=true
    )

    # run Ultranest
    @info "Launching sampler"
    results = sampler.run()

    # output data
    @debug "Sampler done"
    # print("result has these keys:", keys(results), "\n")
    sampler.print_results()
    # sampler.plot()

    return (sampler, results)
end

"""
    run(data::BayesXDataset, energy_range, priors)

Run Bayesian inference on a given set of `data`, considering only the selected
energy range. An gas emission model `(density, temperature) → emissivity` can be provided.
"""
function run(
    data::BayesXDataset,
    energy_range,
    priors;
    nHcol=2.2, # units of 10²² atoms per cm⁻²
    redshift=0.1
)
    @info "Loading data"

    observation, observed_background = load_data(data)

    obs = bin_events(observation.first, energy_range, 2000:100:4000, 2000:100:4000)
    bg = bin_events(observed_background.first, energy_range, 2000:100:4000, 2000:100:4000)

    @assert size(obs) == size(bg)

    transform = make_cube_transform(priors...)

    response_function = load_response(data, energy_range)

    @info "Generating emissions model"

    emission_model = prepare_model_mekal(nHcol, 0.1, LinRange(energy_range[1], energy_range[2], size(response_function)[2] + 1)) # we need this +1 but it seems to be one element too short

    run(obs, bg, response_function, transform, observation.second, observed_background.second, redshift; emission_model=emission_model, pixel_edge_angle=data.pixel_edge_angle)
end

ENV["JULIA_DEBUG"] = "all"

# if abspath(PROGRAM_FILE) == @__FILE__
data = FITSData(
    "/home/ryan/data/chandra/4361/manual3/repro/acisf04361_repro_evt2.fits",
    "/home/ryan/data/chandra/4361/manual3/repro/bg_trimmed_300-7000.fits",
    "/home/ryan/data/chandra/4361/manual3/repro/specx/specx.arf",
    "/home/ryan/data/chandra/4361/manual3/repro/specx/specx.rmf",
    0.492u"arcsecond"
)
priors = [UniformPrior(1.0e17, 8.0e17), UniformPrior(0.08, 0.2)]
run(data, [0.3u"keV", 7u"keV"], priors, nHcol=3.89, redshift=0.164)
# end
